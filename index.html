
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D Data Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 100;
            pointer-events: auto;
        }
        .checkbox-group {
            margin: 5px 0;
        }
        label {
            cursor: pointer;
            user-select: none;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: none;
            max-width: 300px;
            z-index: 100;
            pointer-events: auto;
        }
        #info h3 {
            margin: 0 0 10px 0;
        }
        #info a {
            color: #0066cc;
            text-decoration: none;
        }
        #info a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h3 style="margin-top: 0;">Layers</h3>
        <div class="checkbox-group">
            <label><input type="checkbox" id="layer1" checked> Layer 1</label>
        </div>
        <div class="checkbox-group">
            <label><input type="checkbox" id="layer2" checked> Layer 2</label>
        </div>
        <div class="checkbox-group">
            <label><input type="checkbox" id="layer3" checked> Layer 3</label>
        </div>
    </div>
    <div id="info">
        <h3 id="point-name"></h3>
        <p id="point-class"></p>
        <p id="point-coords"></p>
        <a id="point-link" href="#" target="_blank">Open Link</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Debug logging
        console.log('Script starting...');
        console.log('THREE available:', typeof THREE !== 'undefined');

        const data1 = [{"name": "Point A1", "class": "Class X", "x": 1, "y": 1, "z": 2, "link": "https://example.com/a1"}, {"name": "Point A2", "class": "Class Y", "x": 2, "y": 3, "z": 1, "link": "https://example.com/a2"}, {"name": "Point A3", "class": "Class X", "x": 3, "y": 2, "z": 3, "link": "https://example.com/a3"}];
        const data2 = [{"name": "Point B1", "class": "Class Z", "x": -1, "y": 2, "z": 1, "link": "https://example.com/b1"}, {"name": "Point B2", "class": "Class Y", "x": -2, "y": -1, "z": 2, "link": "https://example.com/b2"}];
        const data3 = [{"name": "Point C1", "class": "Class X", "x": 0, "y": -2, "z": 0, "link": "https://example.com/c1"}, {"name": "Point C2", "class": "Class Z", "x": 1, "y": 0, "z": -1, "link": "https://example.com/c2"}, {"name": "Point C3", "class": "Class Y", "x": -1, "y": 1, "z": -2, "link": "https://example.com/c3"}];

        console.log('Data loaded:', data1.length, data2.length, data3.length);

        let scene, camera, renderer, raycaster, mouse;
        let layer1Group, layer2Group, layer3Group;
        let pointsData = [];
        let controls = {
            mouseDown: false,
            mouseX: 0,
            mouseY: 0,
            cameraTheta: Math.PI / 4,
            cameraPhi: Math.PI / 4,
            cameraRadius: 15
        };

        function init() {
            console.log('Init starting...');

            // Check if THREE is loaded
            if (typeof THREE === 'undefined') {
                alert('Three.js failed to load. Please check your internet connection.');
                return;
            }

            console.log('THREE is loaded');

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            console.log('Scene created');

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            console.log('Renderer created and added to DOM');

            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.5;
            mouse = new THREE.Vector2();

            // Create groups for each layer
            layer1Group = new THREE.Group();
            layer2Group = new THREE.Group();
            layer3Group = new THREE.Group();

            scene.add(layer1Group);
            scene.add(layer2Group);
            scene.add(layer3Group);

            // Add axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Add grid
            const gridHelper = new THREE.GridHelper(20, 20);
            scene.add(gridHelper);

            // Create points for each layer
            createPoints(data1, layer1Group, 0xff0000, 1);
            createPoints(data2, layer2Group, 0x00ff00, 2);
            createPoints(data3, layer3Group, 0x0000ff, 3);
            console.log('Points created, total:', pointsData.length);

            // Event listeners
            document.getElementById('layer1').addEventListener('change', toggleLayer);
            document.getElementById('layer2').addEventListener('change', toggleLayer);
            document.getElementById('layer3').addEventListener('change', toggleLayer);
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);

            // Touch events for mobile
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            updateCameraPosition();
            animate();
            console.log('Init complete!');
        }

        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                controls.mouseDown = true;
                controls.mouseX = event.touches[0].clientX;
                controls.mouseY = event.touches[0].clientY;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && controls.mouseDown) {
                const deltaX = event.touches[0].clientX - controls.mouseX;
                const deltaY = event.touches[0].clientY - controls.mouseY;

                controls.cameraTheta -= deltaX * 0.01;
                controls.cameraPhi -= deltaY * 0.01;

                controls.mouseX = event.touches[0].clientX;
                controls.mouseY = event.touches[0].clientY;

                updateCameraPosition();
            } else if (event.touches.length === 2) {
                // Pinch to zoom
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const distance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                if (controls.lastTouchDistance) {
                    const delta = controls.lastTouchDistance - distance;
                    controls.cameraRadius += delta * 0.05;
                    controls.cameraRadius = Math.max(5, Math.min(50, controls.cameraRadius));
                    updateCameraPosition();
                }

                controls.lastTouchDistance = distance;
            }
        }

        function onTouchEnd(event) {
            controls.mouseDown = false;
            controls.lastTouchDistance = null;
        }

        function onMouseDown(event) {
            controls.mouseDown = true;
            controls.mouseX = event.clientX;
            controls.mouseY = event.clientY;
        }

        function onMouseUp() {
            controls.mouseDown = false;
        }

        function onMouseWheel(event) {
            event.preventDefault();
            controls.cameraRadius += event.deltaY * 0.01;
            controls.cameraRadius = Math.max(5, Math.min(50, controls.cameraRadius));
            updateCameraPosition();
        }

        function updateCameraPosition() {
            camera.position.x = controls.cameraRadius * Math.sin(controls.cameraTheta) * Math.cos(controls.cameraPhi);
            camera.position.y = controls.cameraRadius * Math.sin(controls.cameraPhi);
            camera.position.z = controls.cameraRadius * Math.cos(controls.cameraTheta) * Math.cos(controls.cameraPhi);
            camera.lookAt(0, 0, 0);
        }

        function createPoints(data, group, color, layerId) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];

            data.forEach((point, idx) => {
                positions.push(point.x, point.y, point.z);
                pointsData.push({
                    position: new THREE.Vector3(point.x, point.y, point.z),
                    name: point.name,
                    class: point.class,
                    link: point.link,
                    layerId: layerId,
                    x: point.x,
                    y: point.y,
                    z: point.z
                });
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.5,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geometry, material);
            group.add(points);
        }

        function toggleLayer(event) {
            const layerId = event.target.id;
            if (layerId === 'layer1') {
                layer1Group.visible = event.target.checked;
            } else if (layerId === 'layer2') {
                layer2Group.visible = event.target.checked;
            } else if (layerId === 'layer3') {
                layer3Group.visible = event.target.checked;
            }
        }

        function onMouseMove(event) {
            if (controls.mouseDown) {
                const deltaX = event.clientX - controls.mouseX;
                const deltaY = event.clientY - controls.mouseY;

                controls.cameraTheta -= deltaX * 0.01;
                controls.cameraPhi -= deltaY * 0.01;

                // Allow full rotation - no clamping

                controls.mouseX = event.clientX;
                controls.mouseY = event.clientY;

                updateCameraPosition();
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);

            // Check intersections with visible layers
            const groups = [];
            if (layer1Group.visible) groups.push(...layer1Group.children);
            if (layer2Group.visible) groups.push(...layer2Group.children);
            if (layer3Group.visible) groups.push(...layer3Group.children);

            const intersects = raycaster.intersectObjects(groups);

            if (intersects.length > 0) {
                const point = intersects[0];
                const index = point.index;

                // Find the correct point data considering visible layers
                let currentIndex = 0;
                let selectedPoint = null;

                for (let i = 0; i < pointsData.length; i++) {
                    const pd = pointsData[i];
                    const isVisible = (pd.layerId === 1 && layer1Group.visible) ||
                                    (pd.layerId === 2 && layer2Group.visible) ||
                                    (pd.layerId === 3 && layer3Group.visible);

                    if (isVisible) {
                        if (currentIndex === index) {
                            selectedPoint = pd;
                            break;
                        }
                        currentIndex++;
                    }
                }

                // Fallback: find closest point
                if (!selectedPoint) {
                    const clickPos = point.point;
                    let minDist = Infinity;

                    pointsData.forEach(pd => {
                        const isVisible = (pd.layerId === 1 && layer1Group.visible) ||
                                        (pd.layerId === 2 && layer2Group.visible) ||
                                        (pd.layerId === 3 && layer3Group.visible);

                        if (isVisible) {
                            const dist = pd.position.distanceTo(clickPos);
                            if (dist < minDist) {
                                minDist = dist;
                                selectedPoint = pd;
                            }
                        }
                    });
                }

                if (selectedPoint) {
                    document.getElementById('point-name').textContent = selectedPoint.name;
                    document.getElementById('point-class').textContent = 'Class: ' + selectedPoint.class;
                    document.getElementById('point-coords').textContent = 
                        `Position: (${selectedPoint.x.toFixed(2)}, ${selectedPoint.y.toFixed(2)}, ${selectedPoint.z.toFixed(2)})`;
                    document.getElementById('point-link').href = selectedPoint.link;
                    document.getElementById('info').style.display = 'block';
                }
            } else {
                document.getElementById('info').style.display = 'none';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Wait for page load, then initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
