
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Data Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; touch-action: none; }
        #container { width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255, 255, 255, 0.9); padding: 15px;
            border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 100;
        }
        #info {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); padding: 15px;
            border-radius: 8px; display: none; width: 80%; max-width: 300px; 
            z-index: 100; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        #close-info { position: absolute; top: 5px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #666; }
        label { display: block; margin: 8px 0; cursor: pointer; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h3 style="margin: 0 0 10px 0;">Layers</h3>
        <label><input type="checkbox" id="layer1" checked> TCIP</label>
        <label><input type="checkbox" id="layer2"> GCIP</label>
        <label><input type="checkbox" id="layer3"> ICIP</label>
    </div>
    <div id="info">
        <button id="close-info">&times;</button>
        <h3 id="point-name" style="margin: 0 0 5px 0;"></h3>
        <p id="point-class" style="margin: 5px 0;"></p>
        <p id="point-coords" style="margin: 5px 0; font-size: 0.9em; color: #555;"></p>
        <a id="point-link" href="#" target="_blank" style="color: #0066cc; font-weight: bold;">Open Link</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const data1 = [{"name": "Point A1", "class": "acs", "x": 5, "y": 5, "z": 5, "link": "#"}];
        const data2 = [{"name": "Point B1", "class": "bpp", "x": -5, "y": 2, "z": 3, "link": "#"}];
        const data3 = [{"name": "Point C1", "class": "kps", "x": 0, "y": -5, "z": 0, "link": "#"}];

        const colorMap = {
            "acs": 0x1F77B4,
            "bpp": 0xAEC7E8,
            "clp": 0xFF7F0E,
            "cpmp": 0xFFBB78,
            "cuttingstock": 0x2CA02C,
            "cwlp": 0x98DF8A,
            "gap": 0xD62728,
            "irp": 0xFF9896,
            "job-shop-scheduling": 0x9467BD, 
            "kps": 0xC5B0D5,
            "lotsizing": 0x8C564B,
            "maplabeling": 0xC49C94,
            "nrp": 0xE377C2, 
            "pcp": 0xF7B6D2,
            "relaxed-clique": 0x7F7F7F, 
            "scheduling": 0xC7C7C7,
            "tkp": 0xBCBD22, 
            "train-timetabling": 0xDBDB8D,
            "tup": 0x17BECF,
            "uc": 0x9EDAE5,
            "umcfp": 0x0F6F6A,
            "vcol": 0x8C4FB5,
            "vrp": 0xC28C1C,
            };

        let scene, camera, renderer, raycaster, mouse, orbit;
        let layer1Group, layer2Group, layer3Group;
        let pointsData = [];
        let pointerDownPos = new THREE.Vector2();
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.arc(32, 32, 30, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 15, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // OrbitControls handles rotation and pinch-zoom
            orbit = new THREE.OrbitControls(camera, renderer.domElement);
            orbit.enableDamping = true;

            raycaster = new THREE.Raycaster();
            // Increased threshold for easier tapping on mobile
            raycaster.params.Points.threshold = 0.7;
            mouse = new THREE.Vector2();

            layer1Group = new THREE.Group();
            layer2Group = new THREE.Group();
            layer3Group = new THREE.Group();
            layer1Group.visible = true;
            layer2Group.visible = false;
            layer3Group.visible = false;

            scene.add(layer1Group, layer2Group, layer3Group);

            scene.add(new THREE.AxesHelper(5));
            scene.add(new THREE.GridHelper(20, 20));

            createPoints(data1, layer1Group, 1);
            createPoints(data2, layer2Group, 2);
            createPoints(data3, layer3Group, 3);

            // Interaction Listeners
            renderer.domElement.addEventListener('pointerdown', (e) => {
                pointerDownPos.set(e.clientX, e.clientY);
            });
            renderer.domElement.addEventListener('pointerup', onPointerUp);

            window.addEventListener('resize', onWindowResize);

            ['layer1', 'layer2', 'layer3'].forEach(id => {
                document.getElementById(id).addEventListener('change', (e) => {
                    const group = id === 'layer1' ? layer1Group : id === 'layer2' ? layer2Group : layer3Group;
                    group.visible = e.target.checked;
                });
            });

            document.getElementById('close-info').onclick = () => {
                document.getElementById('info').style.display = 'none';
            };

            animate();
        }

        function createPoints(data, group, layerId) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            data.forEach(p => {
                // Add Position
                positions.push(p.x, p.y, p.z);

                // Add Color based on class
                const hexColor = colorMap[p.class];
                const color = new THREE.Color(hexColor);
                colors.push(color.r, color.g, color.b);

                // Store metadata for raycaster
                pointsData.push({ ...p, layerId, position: new THREE.Vector3(p.x, p.y, p.z) });
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                    size: 0.8, 
                    sizeAttenuation: true,
                    vertexColors: true,
                    map: createCircleTexture(), 
                    transparent: true,          
                    alphaTest: 0.5              
                });

            group.add(new THREE.Points(geometry, material));
        }


        function onPointerUp(event) {
            // Determine if the user tapped or dragged
            const moveDistance = Math.sqrt(
                Math.pow(event.clientX - pointerDownPos.x, 2) + 
                Math.pow(event.clientY - pointerDownPos.y, 2)
            );

            // If move distance is small, it's a tap
            if (moveDistance < 10) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const visibleGroups = [];
                if(layer1Group.visible) visibleGroups.push(...layer1Group.children);
                if(layer2Group.visible) visibleGroups.push(...layer2Group.children);
                if(layer3Group.visible) visibleGroups.push(...layer3Group.children);

                const intersects = raycaster.intersectObjects(visibleGroups);

                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    let selected = null;
                    let minDistance = Infinity;

                    pointsData.forEach(pd => {
                        const isLayerVisible = (pd.layerId === 1 && layer1Group.visible) || 
                                             (pd.layerId === 2 && layer2Group.visible) || 
                                             (pd.layerId === 3 && layer3Group.visible);

                        if (isLayerVisible) {
                            const dist = pd.position.distanceTo(intersect.point);
                            if (dist < minDistance) {
                                minDistance = dist;
                                selected = pd;
                            }
                        }
                    });

                    if (selected) {
                        document.getElementById('point-name').textContent = selected.name;
                        document.getElementById('point-class').textContent = 'Class: ' + selected.class;
                        document.getElementById('point-coords').textContent = `Pos: (${selected.x.toFixed(2)}, ${selected.y.toFixed(2)}, ${selected.z.toFixed(2)})`;
                        document.getElementById('point-link').href = selected.link;
                        document.getElementById('info').style.display = 'block';
                    }
                } else {
                    document.getElementById('info').style.display = 'none';
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
